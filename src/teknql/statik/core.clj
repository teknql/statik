(ns teknql.statik.core
  (:require [garden.core :as garden]
            [hiccup.core :as hiccup]
            [pathetic.core :as path]
            [clojure.java.io :as io]
            [sci.core :as sci]
            [garden.color]
            [garden.stylesheet]
            [garden.units]
            [clj-org.org]
            [clojure.string :as str])
  (:refer-clojure :exclude [compile]))

(defn compile-html
  "Compiles the provided hiccup-style HTML"
  [html]
  (hiccup/html html))

(defn compile-css
  "Compiles the provided garden-style CSS"
  [css]
  (garden/css css))

(defn compile
  "Takes a sequence of assets and optional `data`.

  Returns an output map of relative file paths to the respective file content.

  If `:data` on any of the assets is an arity 1 function, will pass the value
  of `data` into the functions."
  ([assets] (compile assets nil))
  ([assets data]
   (reduce
    (fn compile-asset [acc asset]
      (let [asset-data (:data asset)
            compile-fn (case (:type asset)
                         :html compile-html
                         :css  compile-css)]
        (assoc acc (:path asset) (compile-fn asset-data))))
    {}
    assets)))

(defn write!
  "Takes an output map (as generated by `compile`) and writes it the the proided `out-dir`"
  [output-map out-dir]
  (doseq [[path content] output-map]
    (let [out-path (path/normalize (str out-dir "/" path))]
      (io/make-parents out-path)
      (spit out-path content))))

(def def-asset ^:sci/macro
  (fn [&env &form name data]
    `(do (~'register-asset! ~data)
         (~'def ~name ~data))))

(defn asset-path
  "Returns the asset path of the provided symbol"
  [sym]
  (:path sym))

(defn stylesheet
  "Returns a hiccup link tag for including a css stylesheet for the proided asset"
  [asset]
  [:link {:rel  "stylesheet"
          :type "text/css"
          :href (asset-path asset)}])

(def included-namespaces
  "Namespaces that will automatically be made available to the SCI interpriter"
  '[garden.core
    garden.stylesheet
    garden.color
    garden.units])

(defn- ns->src-path
  "Utility to take a required namespace and load a src path with it"
  [ns]
  (str
    "src/"
    (-> ns
        (str/replace "-" "_")
        (str/replace "." "/"))
    ".clj"))

(defn parse-org [path]
  "Take a path and return a map of title and content."
  (-> path
      (slurp)
      (clj-org.org/parse-org)))

(defn eval-string
  "Ealuates the provided string. Returns a list of assets defined by the file."
  [s]
  (let [assets      (atom [])
        inferred-ns (some-> (re-find #"\(ns ((:?[a-z]|\.|-)+)\b" s)
                            (second)
                            (symbol))]
    (sci/eval-string
      s
      {:load-fn    (fn [ns]
                     (try
                       (let [src-path (ns->src-path ns)]
                         {:file   src-path
                          :source (slurp src-path)})
                       (catch java.io.FileNotFoundException _
                         nil)))
       :namespaces (into {(or inferred-ns
                              'user) {'def-asset       def-asset
                                      'asset-path      asset-path
                                      'stylesheet      stylesheet
                                      'parse-org       parse-org
                                      'register-asset! #(swap! assets conj %)}}
                         (map (juxt identity ns-interns) included-namespaces))})
    @assets))
